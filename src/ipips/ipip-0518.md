---
title: "IPIP-0518: HTTP(S) URLs in Routing V1 API"
date: 2025-10-13
ipip: proposal
editors:
  - name: Marcin Rataj
    github: lidel
    url: https://lidel.org/
    affiliation:
      name: Shipyard
      url: https://ipshipyard.com
relatedIssues:
  - https://github.com/ipfs/specs/issues/192
  - https://github.com/ipfs/specs/issues/496
  - https://github.com/multiformats/multiaddr/issues/63
  - https://github.com/multiformats/multiaddr/issues/87
  - https://github.com/ipshipyard/roadmaps/issues/15
  - https://github.com/ipfs/specs/pull/518
order: 518
tags: ['ipips']
xref:
  - rfc3986
---

## Summary

Allow HTTP(S) URLs alongside multiaddrs in the `Addrs` field of the Peer schema in the Delegated Routing V1 HTTP API to enable easier integration with HTTP-based infrastructure.

## Motivation

The current Delegated Routing V1 HTTP API requires all peer addresses to be encoded as [multiaddrs](https://github.com/multiformats/multiaddr). While multiaddrs provide a flexible and protocol-agnostic way to represent network addresses, many IPFS services are primarily accessible via HTTP(S) endpoints, including:

- IPFS Gateways (both path and subdomain gateways)
- Delegated routing endpoints themselves
- HTTP-based content providers and pinning services

Converting HTTP(S) URLs to multiaddrs requires additional complexity:
- HTTP URLs must be encoded as `/dns4/example.com/tcp/80/http` or `/dns4/example.com/tcp/443/https`
- This conversion is not intuitive for developers familiar with web standards
- It does not capture HTTP semantics where the same website can be exposed on both TCP (HTTP/1.1, HTTP/2) and UDP (HTTP/3)
- A single `https://example.com` URL automatically supports multiple transport protocols, but multiaddr representation requires separate entries for each transport
- Parsing multiaddrs back to URLs requires additional libraries and logic

By allowing native HTTP(S) URLs in the `Addrs` field, we can:
- Simplify integration with existing web infrastructure
- Reduce conversion overhead for HTTP-based services
- Improve developer experience by using familiar URL formats
- Improve interoperability with the wider HTTP and URI ecosystem
- Enable future-proofing for non-HTTP URI schemes in ecosystem experimentation without requiring permission from gatekeepers
- Maintain backward compatibility with existing multiaddr-based implementations

## Detailed design

### Changes to the Peer Schema

The `Addrs` field in the [Peer Schema](https://specs.ipfs.tech/routing/http-routing-v1/#peer-schema) will accept both multiaddr strings and HTTP(S) URL strings:

```json
{
  "Schema": "peer",
  "ID": "bafz...",
  "Addrs": [
    "/ip4/192.168.1.1/tcp/4001",
    "/dns4/libp2p-peer.example.com/tcp/4001/ws",
    "https://trustless-gateway.example.org",
    "https://custom-port.example.net:8443"
  ],
  "Protocols": ["transport-bitswap", ...]
}
```

### Parsing Logic

Implementations MUST use the following logic to distinguish between multiaddrs and URLs:

1. If a string in `Addrs` starts with `/` (forward slash), parse it as a multiaddr
2. Otherwise, attempt to parse it as a URI according to :cite[rfc3986]
3. If neither parsing succeeds, or if the address type is not supported by the implementation, the address MUST be ignored (skipped)
4. Processing MUST continue with the remaining addresses in the array
5. Implementations SHOULD log warnings for addresses they cannot parse or do not support

This approach ensures forward compatibility: new address types can be introduced without breaking existing clients, as unsupported addresses are simply skipped.

### Supported URL Schemes

Initially, only the following URL schemes SHOULD be supported:
- `http://` - HTTP endpoints
- `https://` - HTTPS endpoints

Future specifications MAY add support for additional schemes.

### URL Requirements

URLs in the `Addrs` field:
- MUST be absolute URLs (not relative)
- MUST include the scheme (`http://` or `https://`)
- SHOULD NOT include paths, query parameters, and fragments, but clients MUST account for them being present as part of defensive programming and either act on them, ignore them, or skip such addresses
- SHOULD point to endpoints that support IPFS protocols listed in the `Protocols` field

### Examples

#### HTTPS-only Content Provider

```json
{
  "Schema": "peer",
  "ID": "12D3KooWExample...",
  "Addrs": [
    "https://trustless-gateway.example.com"
  ],
  "Protocols": ["transport-ipfs-gateway-http"]
}
```

#### Hybrid Peer with Multiple Transports

```json
{
  "Schema": "peer",
  "ID": "12D3KooWExample...",
  "Addrs": [
    "/ip4/192.168.1.1/tcp/4001",
    "/ip4/192.168.1.1/udp/4001/quic-v1",
    "https://my-node.example.org:8080"
  ],
  "Protocols": ["transport-bitswap", "transport-ipfs-gateway-http"]
}
```

## Design rationale

### Why not create a new field?

Adding URLs to the existing `Addrs` field rather than creating a new field (e.g., `URLs`) has several advantages:
- Maintains backward compatibility - existing clients continue to work
- Avoids duplication when the same endpoint can be expressed as both multiaddr and URL
- Simplifies the schema without adding complexity
- Follows the principle that addresses are addresses, regardless of encoding

### Clear disambiguation

The parsing rule (strings starting with `/` are multiaddrs, others are URIs) provides clear, unambiguous disambiguation:
- Multiaddrs ALWAYS start with `/` by specification
- Valid URLs NEVER start with `/` (they start with a scheme like `http://`)
- This makes parsing deterministic and fast

### Incremental adoption

This change allows for incremental adoption:
- Clients that don't understand URLs can simply skip them
- Servers can start including URLs immediately for URL-aware clients
- No flag day or coordinated upgrade required

## User benefit

This change benefits multiple user groups:

### For developers

- Simplified integration with existing HTTP infrastructure
- No need for multiaddr encoding/decoding libraries for HTTP endpoints
- Clearer, more readable configurations and debugging
- Barrier of adoption is removed: developers can implement HTTP-based routing and retrieval without having to re-implement libp2p concepts like Multiaddr, making it orders of magnitude easier to create light IPFS clients

### For service providers

- Easier to advertise HTTP-based services
- Can provide URLs that include paths and query parameters if needed
- Reduced complexity in route announcements

### For end users

- Potentially faster connection establishment to HTTP services
- Better compatibility with web-based IPFS implementations
- Lower barrier for creating new clients gives end users more choice and less vendor lock-in
- Provides viable escape path in case any of the open source projects gets captured by forces that do not put end user's good first

## Compatibility

This IPIP is fully backward and forward compatible:

### For existing clients

- Clients that only understand multiaddrs MUST skip URL entries they don't recognize (this is already implemented and proven to work when new protocols like `/quic`, `/quic-v1`, `/webtransport`, and `/webrtc-direct` were rolled out)
- Clients MUST continue processing remaining addresses even when encountering unsupported entries
- No changes required to existing parsing logic for multiaddr strings
- The `Addrs` field remains an array of strings

### Forward compatibility

- The requirement to skip unsupported addresses ensures that new address types can be added in the future
- Clients MUST NOT fail when encountering unknown address formats
- This allows the ecosystem to evolve without breaking existing implementations or without the need for permission or central coordination

### For existing servers

- Servers can continue sending only multiaddrs
- No changes required if URLs are not used

### Migration path

1. Servers can start including both multiaddrs and URLs for the same endpoints
2. Clients can be updated to parse URLs at their own pace
3. Eventually, servers may choose to only send URLs for HTTP(S) endpoints

## Security

### URL validation

Implementations SHOULD validate URLs to prevent security issues:
- Verify the URL scheme is allowed (`http://` or `https://`)
- Consider rate limiting for URL-based connections if non-success (!=200) responses are received
- Validate URL length limits (DNS names are limited to 253 characters; practical URL length is typically 2048-8192 characters depending on implementation)

### HTTPS preference

Implementations SHOULD ignore `http://` URLs and only act on `https://` URLs for security and performance (HTTP/2 multiplexing) reasons.

The `http://` scheme SHOULD be allowed only for testing and private LAN deployments, and only when an explicit opt-in flag is set by the end user.

### DNS considerations

URLs rely on DNS resolution, which has different security properties than IP-based multiaddrs. The same rules that apply to `/dns`, `/dns4`, and `/dns6` multiaddrs apply here:
- DNS responses can be spoofed if DNSSEC is not used
- Clients SHOULD use secure DNS transports where available
- Certificate validation MUST be performed for HTTPS URLs

## Alternatives

### Separate URL field

Adding a separate `URLs` field was considered but rejected because:
- It would complicate the schema
- It could lead to confusion about which field to use
- It wouldn't be backward compatible

### URL-to-multiaddr conversion requirement

Requiring all HTTP endpoints to be encoded as multiaddrs was the status quo but has proven cumbersome in practice. Multiple implementations on NPM and Golang alone behaved in slightly different fashion around how the schema, default port, optional path, fragment, and HTTP basic-auth were handled. This led to hard-to-debug errors due to multiaddr-URL conversion being ultimately lossy and 1:1 round-trip not being possible (see [multiaddr#63](https://github.com/multiformats/multiaddr/issues/63)).

### Custom multiaddr protocols with keyword arguments

Adding keyword arguments to multiaddr protocols was proposed in [multiaddr#87](https://github.com/multiformats/multiaddr/issues/87) to allow expressing `https://` URLs as multiaddrs without losing any information on conversion. This approach was not adopted because it would add even more complexity that multiaddr implementers would have to deal with.

This solution was not feasible - adding native URI support is better as it removes walls and obstacles, rather than making existing ones taller.

## Test fixtures

Implementations can test compatibility using these example responses:

### Mixed addresses response

```json
{
  "Providers": [
    {
      "Schema": "peer",
      "ID": "12D3KooWTest1...",
      "Addrs": [
        "/ip4/127.0.0.1/tcp/4001",
        "http://localhost:8080",
        "/dns4/example.com/tcp/443/https",
        "https://example.net"
      ],
      "Protocols": ["transport-bitswap", "transport-ipfs-gateway-http"]
    }
  ]
}
```

### URL-only response

```json
{
  "Providers": [
    {
      "Schema": "peer",
      "ID": "12D3KooWTest2...",
      "Addrs": [
        "https://trustless-gateway.example.org"
      ],
      "Protocols": ["transport-ipfs-gateway-http"]
    }
  ]
}
```

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).